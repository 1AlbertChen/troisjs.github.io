import{f as e,n as t,r as s,o as r,c as o,w as i,b as n}from"./app.efb59aa7.js";import{Z as a,a4 as h,a3 as l,_ as c,bn as u,az as m,ao as p,r as d,ap as f,aq as g,B as v,w as x,j as y,V as b,m as N,A as w,a_ as U,bi as S}from"./OrbitControls.94891aa4.js";import{C as A,R as z,S as P,u as V,g as k,P as B}from"./useTextures.f8ab31b2.js";import{b as M,l as T}from"./tools.1b52637e.js";var E=e({extends:A,name:"PerspectiveCamera",inject:["three"],props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:{x:0,y:0,z:0}},lookAt:{type:Object,default:null}},created(){this.camera=new a(this.fov,this.aspect,this.near,this.far),M(this,"position",this.camera),this.lookAt&&this.camera.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),t((()=>this.lookAt),(e=>{this.camera.lookAt(e.x,e.y,e.z)}),{deep:!0}),["aspect","far","fov","near"].forEach((e=>{t((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},__hmrId:"PerspectiveCamera"});const G=new h,_=new l,I=new p;function C(){this.uuid=c.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}C.prototype=Object.assign(Object.create(u.prototype),{constructor:C,isGeometry:!0,applyMatrix4:function(e){const t=(new m).getNormalMatrix(e);for(let s=0,r=this.vertices.length;s<r;s++){this.vertices[s].applyMatrix4(e)}for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s];e.normal.applyMatrix3(t).normalize();for(let s=0,r=e.vertexNormals.length;s<r;s++)e.vertexNormals[s].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return G.makeRotationX(e),this.applyMatrix4(G),this},rotateY:function(e){return G.makeRotationY(e),this.applyMatrix4(G),this},rotateZ:function(e){return G.makeRotationZ(e),this.applyMatrix4(G),this},translate:function(e,t,s){return G.makeTranslation(e,t,s),this.applyMatrix4(G),this},scale:function(e,t,s){return G.makeScale(e,t,s),this.applyMatrix4(G),this},lookAt:function(e){return _.lookAt(e),_.updateMatrix(),this.applyMatrix4(_.matrix),this},fromBufferGeometry:function(e){const t=this,s=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const o=r.position,i=r.normal,n=r.color,a=r.uv,h=r.uv2;void 0!==h&&(this.faceVertexUvs[1]=[]);for(let u=0;u<o.count;u++)t.vertices.push((new p).fromBufferAttribute(o,u)),void 0!==n&&t.colors.push((new d).fromBufferAttribute(n,u));function l(e,s,r,o){const l=void 0===n?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[r].clone()],c=void 0===i?[]:[(new p).fromBufferAttribute(i,e),(new p).fromBufferAttribute(i,s),(new p).fromBufferAttribute(i,r)],u=new R(e,s,r,c,l,o);t.faces.push(u),void 0!==a&&t.faceVertexUvs[0].push([(new b).fromBufferAttribute(a,e),(new b).fromBufferAttribute(a,s),(new b).fromBufferAttribute(a,r)]),void 0!==h&&t.faceVertexUvs[1].push([(new b).fromBufferAttribute(h,e),(new b).fromBufferAttribute(h,s),(new b).fromBufferAttribute(h,r)])}const c=e.groups;if(c.length>0)for(let u=0;u<c.length;u++){const e=c[u],t=e.start;for(let r=t,o=t+e.count;r<o;r+=3)void 0!==s?l(s.getX(r),s.getX(r+1),s.getX(r+2),e.materialIndex):l(r,r+1,r+2,e.materialIndex)}else if(void 0!==s)for(let u=0;u<s.count;u+=3)l(s.getX(u),s.getX(u+1),s.getX(u+2));else for(let u=0;u<o.count;u+=3)l(u,u+1,u+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(I).negate(),this.translate(I.x,I.y,I.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,s=0===t?1:1/t,r=new h;return r.set(s,0,0,-s*e.x,0,s,0,-s*e.y,0,0,s,-s*e.z,0,0,0,1),this.applyMatrix4(r),this},computeFaceNormals:function(){const e=new p,t=new p;for(let s=0,r=this.faces.length;s<r;s++){const r=this.faces[s],o=this.vertices[r.a],i=this.vertices[r.b],n=this.vertices[r.c];e.subVectors(n,i),t.subVectors(o,i),e.cross(t),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let s=0,r=this.vertices.length;s<r;s++)t[s]=new p;if(e){const e=new p,s=new p;for(let r=0,o=this.faces.length;r<o;r++){const o=this.faces[r],i=this.vertices[o.a],n=this.vertices[o.b],a=this.vertices[o.c];e.subVectors(a,n),s.subVectors(i,n),e.cross(s),t[o.a].add(e),t[o.b].add(e),t[o.c].add(e)}}else{this.computeFaceNormals();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];t[s.a].add(s.normal),t[s.b].add(s.normal),t[s.c].add(s.normal)}}for(let s=0,r=this.vertices.length;s<r;s++)t[s].normalize();for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s],r=e.vertexNormals;3===r.length?(r[0].copy(t[e.a]),r[1].copy(t[e.b]),r[2].copy(t[e.c])):(r[0]=t[e.a].clone(),r[1]=t[e.b].clone(),r[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,s=e.vertexNormals.length;t<s;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new C;e.faces=this.faces;for(let t=0,s=this.morphTargets.length;t<s;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(let t=0,r=this.faces.length;t<r;t++){const t=new p,r={a:new p,b:new p,c:new p};e.push(t),s.push(r)}}const s=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],r=s.faceNormals[e],o=s.vertexNormals[e];r.copy(t.normal),o.a.copy(t.vertexNormals[0]),o.b.copy(t.vertexNormals[1]),o.c.copy(t.vertexNormals[2])}}for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new f),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new g),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,s=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const o=this.vertices.length,i=this.vertices,n=e.vertices,a=this.faces,h=e.faces,l=this.colors,c=e.colors;void 0!==t&&(r=(new m).getNormalMatrix(t));for(let u=0,m=n.length;u<m;u++){const e=n[u].clone();void 0!==t&&e.applyMatrix4(t),i.push(e)}for(let u=0,m=c.length;u<m;u++)l.push(c[u].clone());for(let u=0,m=h.length;u<m;u++){const e=h[u];let t,i;const n=e.vertexNormals,l=e.vertexColors,c=new R(e.a+o,e.b+o,e.c+o);c.normal.copy(e.normal),void 0!==r&&c.normal.applyMatrix3(r).normalize();for(let s=0,o=n.length;s<o;s++)t=n[s].clone(),void 0!==r&&t.applyMatrix3(r).normalize(),c.vertexNormals.push(t);c.color.copy(e.color);for(let s=0,r=l.length;s<r;s++)i=l[s],c.vertexColors.push(i.clone());c.materialIndex=e.materialIndex+s,a.push(c)}for(let u=0,m=e.faceVertexUvs.length;u<m;u++){const t=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++)r.push(s[e].clone());this.faceVertexUvs[u].push(r)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(e=4){const t={},s=[],r=[],o=Math.pow(10,e);for(let a=0,h=this.vertices.length;a<h;a++){const e=this.vertices[a],i=Math.round(e.x*o)+"_"+Math.round(e.y*o)+"_"+Math.round(e.z*o);void 0===t[i]?(t[i]=a,s.push(this.vertices[a]),r[a]=s.length-1):r[a]=r[t[i]]}const i=[];for(let a=0,h=this.faces.length;a<h;a++){const e=this.faces[a];e.a=r[e.a],e.b=r[e.b],e.c=r[e.c];const t=[e.a,e.b,e.c];for(let s=0;s<3;s++)if(t[s]===t[(s+1)%3]){i.push(a);break}}for(let a=i.length-1;a>=0;a--){const e=i[a];this.faces.splice(e,1);for(let t=0,s=this.faceVertexUvs.length;t<s;t++)this.faceVertexUvs[t].splice(e,1)}const n=this.vertices.length-s.length;return this.vertices=s,n},setFromPoints:function(e){this.vertices=[];for(let t=0,s=e.length;t<s;t++){const s=e[t];this.vertices.push(new p(s.x,s.y,s.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let n=0;n<t;n++)e[n]._id=n;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let o,i;s&&s.length===t&&(o=[]),r&&r.length===t&&(i=[]);for(let n=0;n<t;n++){const t=e[n]._id;o&&o.push(s[t]),i&&i.push(r[t])}o&&(this.faceVertexUvs[0]=o),i&&(this.faceVertexUvs[1]=i)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let p=0;p<this.vertices.length;p++){const e=this.vertices[p];t.push(e.x,e.y,e.z)}const s=[],r=[],o={},i=[],n={},a=[],h={};for(let p=0;p<this.faces.length;p++){const e=this.faces[p],t=!0,r=!1,o=void 0!==this.faceVertexUvs[0][p],i=e.normal.length()>0,n=e.vertexNormals.length>0,a=1!==e.color.r||1!==e.color.g||1!==e.color.b,h=e.vertexColors.length>0;let d=0;if(d=l(d,0,0),d=l(d,1,t),d=l(d,2,r),d=l(d,3,o),d=l(d,4,i),d=l(d,5,n),d=l(d,6,a),d=l(d,7,h),s.push(d),s.push(e.a,e.b,e.c),s.push(e.materialIndex),o){const e=this.faceVertexUvs[0][p];s.push(m(e[0]),m(e[1]),m(e[2]))}if(i&&s.push(c(e.normal)),n){const t=e.vertexNormals;s.push(c(t[0]),c(t[1]),c(t[2]))}if(a&&s.push(u(e.color)),h){const t=e.vertexColors;s.push(u(t[0]),u(t[1]),u(t[2]))}}function l(e,t,s){return s?e|1<<t:e&~(1<<t)}function c(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==o[t]||(o[t]=r.length/3,r.push(e.x,e.y,e.z)),o[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==n[t]||(n[t]=i.length,i.push(e.getHex())),n[t]}function m(e){const t=e.x.toString()+e.y.toString();return void 0!==h[t]||(h[t]=a.length/2,a.push(e.x,e.y)),h[t]}return e.data={},e.data.vertices=t,e.data.normals=r,i.length>0&&(e.data.colors=i),a.length>0&&(e.data.uvs=[a]),e.data.faces=s,e},clone:function(){return(new C).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,m=t.length;u<m;u++)this.vertices.push(t[u].clone());const s=e.colors;for(let u=0,m=s.length;u<m;u++)this.colors.push(s[u].clone());const r=e.faces;for(let u=0,m=r.length;u<m;u++)this.faces.push(r[u].clone());for(let u=0,m=e.faceVertexUvs.length;u<m;u++){const t=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++){const t=s[e];r.push(t.clone())}this.faceVertexUvs[u].push(r)}}const o=e.morphTargets;for(let u=0,m=o.length;u<m;u++){const e={};if(e.name=o[u].name,void 0!==o[u].vertices){e.vertices=[];for(let t=0,s=o[u].vertices.length;t<s;t++)e.vertices.push(o[u].vertices[t].clone())}if(void 0!==o[u].normals){e.normals=[];for(let t=0,s=o[u].normals.length;t<s;t++)e.normals.push(o[u].normals[t].clone())}this.morphTargets.push(e)}const i=e.morphNormals;for(let u=0,m=i.length;u<m;u++){const e={};if(void 0!==i[u].vertexNormals){e.vertexNormals=[];for(let t=0,s=i[u].vertexNormals.length;t<s;t++){const s=i[u].vertexNormals[t],r={};r.a=s.a.clone(),r.b=s.b.clone(),r.c=s.c.clone(),e.vertexNormals.push(r)}}if(void 0!==i[u].faceNormals){e.faceNormals=[];for(let t=0,s=i[u].faceNormals.length;t<s;t++)e.faceNormals.push(i[u].faceNormals[t].clone())}this.morphNormals.push(e)}const n=e.skinWeights;for(let u=0,m=n.length;u<m;u++)this.skinWeights.push(n[u].clone());const a=e.skinIndices;for(let u=0,m=a.length;u<m;u++)this.skinIndices.push(a[u].clone());const h=e.lineDistances;for(let u=0,m=h.length;u<m;u++)this.lineDistances.push(h[u]);const l=e.boundingBox;null!==l&&(this.boundingBox=l.clone());const c=e.boundingSphere;return null!==c&&(this.boundingSphere=c.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},toBufferGeometry:function(){const e=(new F).fromGeometry(this),t=new v,s=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",new x(s,3).copyVector3sArray(e.vertices)),e.normals.length>0){const s=new Float32Array(3*e.normals.length);t.setAttribute("normal",new x(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const s=new Float32Array(3*e.colors.length);t.setAttribute("color",new x(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const s=new Float32Array(2*e.uvs.length);t.setAttribute("uv",new x(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const s=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",new x(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const r in e.morphTargets){const s=[],o=e.morphTargets[r];for(let e=0,t=o.length;e<t;e++){const t=o[e],r=new y(3*t.data.length,3);r.name=t.name,s.push(r.copyVector3sArray(t.data))}t.morphAttributes[r]=s}if(e.skinIndices.length>0){const s=new y(4*e.skinIndices.length,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const s=new y(4*e.skinWeights.length,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t},computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},dispose:function(){this.dispatchEvent({type:"dispose"})}}),C.createBufferGeometryFromObject=function(e){let t=new v;const s=e.geometry;if(e.isPoints||e.isLine){const e=new y(3*s.vertices.length,3),r=new y(3*s.colors.length,3);if(t.setAttribute("position",e.copyVector3sArray(s.vertices)),t.setAttribute("color",r.copyColorsArray(s.colors)),s.lineDistances&&s.lineDistances.length===s.vertices.length){const e=new y(s.lineDistances.length,1);t.setAttribute("lineDistance",e.copyArray(s.lineDistances))}null!==s.boundingSphere&&(t.boundingSphere=s.boundingSphere.clone()),null!==s.boundingBox&&(t.boundingBox=s.boundingBox.clone())}else e.isMesh&&(t=s.toBufferGeometry());return t};class F{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,r,o;const i=e.faces;for(r=0;r<i.length;r++){const e=i[r];e.materialIndex!==o&&(o=e.materialIndex,void 0!==s&&(s.count=3*r-s.start,t.push(s)),s={start:3*r,materialIndex:o})}void 0!==s&&(s.count=3*r-s.start,t.push(s)),this.groups=t}fromGeometry(e){const t=e.faces,s=e.vertices,r=e.faceVertexUvs,o=r[0]&&r[0].length>0,i=r[1]&&r[1].length>0,n=e.morphTargets,a=n.length;let h;if(a>0){h=[];for(let e=0;e<a;e++)h[e]={name:n[e].name,data:[]};this.morphTargets.position=h}const l=e.morphNormals,c=l.length;let u;if(c>0){u=[];for(let e=0;e<c;e++)u[e]={name:l[e].name,data:[]};this.morphTargets.normal=u}const m=e.skinIndices,p=e.skinWeights,d=m.length===s.length,f=p.length===s.length;s.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let g=0;g<t.length;g++){const e=t[g];this.vertices.push(s[e.a],s[e.b],s[e.c]);const v=e.vertexNormals;if(3===v.length)this.normals.push(v[0],v[1],v[2]);else{const t=e.normal;this.normals.push(t,t,t)}const x=e.vertexColors;if(3===x.length)this.colors.push(x[0],x[1],x[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===o){const e=r[0][g];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",g),this.uvs.push(new b,new b,new b))}if(!0===i){const e=r[1][g];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",g),this.uvs2.push(new b,new b,new b))}for(let t=0;t<a;t++){const s=n[t].vertices;h[t].data.push(s[e.a],s[e.b],s[e.c])}for(let t=0;t<c;t++){const e=l[t].vertexNormals[g];u[t].data.push(e.a,e.b,e.c)}d&&this.skinIndices.push(m[e.a],m[e.b],m[e.c]),f&&this.skinWeights.push(p[e.a],p[e.b],p[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class R{constructor(e,t,s,r,o,i=0){this.a=e,this.b=t,this.c=s,this.normal=r&&r.isVector3?r:new p,this.vertexNormals=Array.isArray(r)?r:[],this.color=o&&o.isColor?o:new d,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=i}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}class j{constructor(e){Object.entries(e).forEach((([e,t])=>{this[e]=t})),this.o3d=new l,this.uProgress={value:0},this.uvScale=new b,this.initMaterial(),this.initPlane()}initMaterial(){this.material=new N({side:w,transparent:!0,map:this.texture,onBeforeCompile:e=>{e.uniforms.progress=this.uProgress,e.uniforms.uvScale={value:this.uvScale},e.vertexShader="\n          uniform float progress;\n          uniform vec2 uvScale;\n\n          attribute vec3 offset;\n          attribute vec3 rotation;\n          attribute vec2 uvOffset;\n\n          mat3 rotationMatrixXYZ(vec3 r)\n          {\n            float cx = cos(r.x);\n            float sx = sin(r.x);\n            float cy = cos(r.y);\n            float sy = sin(r.y);\n            float cz = cos(r.z);\n            float sz = sin(r.z);\n\n            return mat3(\n               cy * cz, cx * sz + sx * sy * cz, sx * sz - cx * sy * cz,\n              -cy * sz, cx * cz - sx * sy * sz, sx * cz + cx * sy * sz,\n                    sy,               -sx * cy,                cx * cy\n            );\n          }\n        "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <uv_vertex>","\n          #include <uv_vertex>\n          vUv = vUv * uvScale + uvOffset;\n        "),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n          mat3 rotMat = rotationMatrixXYZ(progress * rotation);\n          transformed = rotMat * transformed;\n\n          vec4 mvPosition = vec4(transformed, 1.0);\n          #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n          #endif\n\n          mvPosition.xyz += progress * offset;\n\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n        ")}})}initPlane(){const{width:e,wWidth:t,wHeight:s}=this.screen;this.wSize=this.size*t/e,this.nx=Math.ceil(t/this.wSize)+1,this.ny=Math.ceil(s/this.wSize)+1,this.icount=this.nx*this.ny,this.initGeometry(),this.initUV(),this.initAnimAttributes(),this.imesh&&this.o3d.remove(this.imesh),this.imesh=new U(this.bGeometry,this.material,this.icount),this.o3d.add(this.imesh);const r=new l;let o=0,i=-(t-(t-this.nx*this.wSize))/2+this.dx;for(let n=0;n<this.nx;n++){let e=-(s-(s-this.ny*this.wSize))/2+this.dy;for(let t=0;t<this.ny;t++)r.position.set(i,e,0),r.updateMatrix(),this.imesh.setMatrixAt(o++,r.matrix),e+=this.wSize;i+=this.wSize}}initGeometry(){const e=new C;e.vertices.push(new p(0,0,0)),e.vertices.push(new p(this.wSize,0,0)),e.vertices.push(new p(0,this.wSize,0)),e.vertices.push(new p(this.wSize,this.wSize,0)),e.faces.push(new R(0,2,1)),e.faces.push(new R(2,3,1)),e.faceVertexUvs[0].push([new b(0,0),new b(0,1),new b(1,0)]),e.faceVertexUvs[0].push([new b(0,1),new b(1,1),new b(1,0)]),this.dx=this.wSize/2,this.dy=this.wSize/2,e.translate(-this.dx,-this.dy,0),this.bGeometry=e.toBufferGeometry()}initAnimAttributes(){const{randFloat:e,randFloatSpread:t}=c,s=new p,r=new Float32Array(3*this.icount);for(let n=0;n<r.length;n+=3)1===this.anim?s.set(t(10),e(50,100),e(20,50)).toArray(r,n):s.set(t(20),t(20),e(20,200)).toArray(r,n);this.bGeometry.setAttribute("offset",new S(r,3));const o=new Float32Array(3*this.icount),i=4*Math.PI;for(let n=0;n<o.length;n+=3)o[n]=t(i),o[n+1]=t(i),o[n+2]=t(i);this.bGeometry.setAttribute("rotation",new S(o,3))}initUV(){const e=this.nx/this.ny,t=this.texture.image.width/this.texture.image.height;e>t?this.uvScale.set(1/this.nx,t/e/this.ny):this.uvScale.set(e/t/this.nx,1/this.ny);const s=this.uvScale.x*this.nx,r=this.uvScale.y*this.ny,o=new b,i=new Float32Array(2*this.icount);for(let n=0;n<this.nx;n++)for(let e=0;e<this.ny;e++)o.set(this.uvScale.x*n+(1-s)/2,this.uvScale.y*e+(1-r)/2).toArray(i,2*(n*this.ny+e));this.bGeometry.setAttribute("uvOffset",new S(i,2))}setTexture(e){this.texture=e,this.material.map=e,this.initUV()}resize(){this.initPlane()}}const D=e({components:{Camera:E,Renderer:z,Scene:P},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup:()=>({loader:V(),progress:0,targetProgress:0}),mounted(){this.renderer=this.$refs.renderer,this.three=this.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.three.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),k.fromTo(this.plane1.uProgress,{value:-2},{value:0,duration:2.5,ease:B.easeOut});const e=this.three.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.renderer.onBeforeRender(this.updateProgress),this.renderer.onAfterResize(this.onResize)},initScene(){const e=this.three.renderer,t=this.$refs.scene.scene;this.plane1=new j({renderer:e,screen:this.three.size,size:10,anim:1,texture:this.loader.textures[0]}),this.plane2=new j({renderer:e,screen:this.three.size,size:10,anim:2,texture:this.loader.textures[1]}),this.setPlanesProgress(0),this.planes=new l,this.planes.add(this.plane1.o3d),this.planes.add(this.plane2.o3d),t.add(this.planes)},onResize(){this.plane1.resize(),this.plane2.resize()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.three.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=T(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,r=e%1;if(t>0&&r<s||t<0&&s<r){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.plane1.setTexture(this.loader.textures[t]),this.plane2.setTexture(this.loader.textures[s])}this.progress=e,this.setPlanesProgress(this.progress%1)},setPlanesProgress(e){this.plane1.uProgress.value=e,this.plane2.uProgress.value=-1+e,this.plane1.material.opacity=1-e,this.plane2.material.opacity=e,this.plane1.o3d.position.z=e,this.plane2.o3d.position.z=e-1}}});D.render=function(e,t,a,h,l,c){const u=s("Camera"),m=s("Scene"),p=s("Renderer");return r(),o(p,{ref:"renderer",antialias:"",resize:""},{default:i((()=>[n(u,{ref:"camera",position:{z:150}},null,512),n(m,{ref:"scene"},null,512)])),_:1},512)};const W={components:{Slider:D},data:()=>({images:[{src:"/assets/images/img1.jpg"},{src:"/assets/images/img2.jpg"},{src:"/assets/images/img3.jpg"},{src:"/assets/images/img4.jpg"}]})};W.render=function(e,t,i,n,a,h){const l=s("Slider");return r(),o(l,{images:a.images},null,8,["images"])};export default W;
