import{aJ as e,an as t,s,a$ as r,b0 as o,m as n,aZ as i,a_ as a,B as h,aw as l,e as c,V as u,ao as m,h as p,am as d,ad as g,b1 as f,ap as v}from"./OrbitControls.97338009.js";import{u as x,g as y,P as b}from"./useTextures.9de50028.js";import{C as N}from"./PerspectiveCamera.57c0686d.js";import{R as w,S as U}from"./Scene.7c171775.js";import{l as S}from"./tools.5e5d6ccd.js";import{r as A,o as z,c as P,w as V,b as B}from"./app.b14967d2.js";const M=new e,k=new t,T=new s;function E(){this.uuid=m.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}E.prototype=Object.assign(Object.create(r.prototype),{constructor:E,isGeometry:!0,applyMatrix4:function(e){const t=(new o).getNormalMatrix(e);for(let s=0,r=this.vertices.length;s<r;s++){this.vertices[s].applyMatrix4(e)}for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s];e.normal.applyMatrix3(t).normalize();for(let s=0,r=e.vertexNormals.length;s<r;s++)e.vertexNormals[s].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return M.makeRotationX(e),this.applyMatrix4(M),this},rotateY:function(e){return M.makeRotationY(e),this.applyMatrix4(M),this},rotateZ:function(e){return M.makeRotationZ(e),this.applyMatrix4(M),this},translate:function(e,t,s){return M.makeTranslation(e,t,s),this.applyMatrix4(M),this},scale:function(e,t,s){return M.makeScale(e,t,s),this.applyMatrix4(M),this},lookAt:function(e){return k.lookAt(e),k.updateMatrix(),this.applyMatrix4(k.matrix),this},fromBufferGeometry:function(e){const t=this,r=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const i=o.position,a=o.normal,h=o.color,l=o.uv,c=o.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let u=0;u<i.count;u++)t.vertices.push((new s).fromBufferAttribute(i,u)),void 0!==h&&t.colors.push((new n).fromBufferAttribute(h,u));function m(e,r,o,n){const i=void 0===h?[]:[t.colors[e].clone(),t.colors[r].clone(),t.colors[o].clone()],m=void 0===a?[]:[(new s).fromBufferAttribute(a,e),(new s).fromBufferAttribute(a,r),(new s).fromBufferAttribute(a,o)],p=new I(e,r,o,m,i,n);t.faces.push(p),void 0!==l&&t.faceVertexUvs[0].push([(new u).fromBufferAttribute(l,e),(new u).fromBufferAttribute(l,r),(new u).fromBufferAttribute(l,o)]),void 0!==c&&t.faceVertexUvs[1].push([(new u).fromBufferAttribute(c,e),(new u).fromBufferAttribute(c,r),(new u).fromBufferAttribute(c,o)])}const p=e.groups;if(p.length>0)for(let s=0;s<p.length;s++){const e=p[s],t=e.start;for(let s=t,o=t+e.count;s<o;s+=3)void 0!==r?m(r.getX(s),r.getX(s+1),r.getX(s+2),e.materialIndex):m(s,s+1,s+2,e.materialIndex)}else if(void 0!==r)for(let s=0;s<r.count;s+=3)m(r.getX(s),r.getX(s+1),r.getX(s+2));else for(let s=0;s<i.count;s+=3)m(s,s+1,s+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(T).negate(),this.translate(T.x,T.y,T.z),this},normalize:function(){this.computeBoundingSphere();const t=this.boundingSphere.center,s=this.boundingSphere.radius,r=0===s?1:1/s,o=new e;return o.set(r,0,0,-r*t.x,0,r,0,-r*t.y,0,0,r,-r*t.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){const e=new s,t=new s;for(let s=0,r=this.faces.length;s<r;s++){const r=this.faces[s],o=this.vertices[r.a],n=this.vertices[r.b],i=this.vertices[r.c];e.subVectors(i,n),t.subVectors(o,n),e.cross(t),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let r=0,o=this.vertices.length;r<o;r++)t[r]=new s;if(e){const e=new s,r=new s;for(let s=0,o=this.faces.length;s<o;s++){const o=this.faces[s],n=this.vertices[o.a],i=this.vertices[o.b],a=this.vertices[o.c];e.subVectors(a,i),r.subVectors(n,i),e.cross(r),t[o.a].add(e),t[o.b].add(e),t[o.c].add(e)}}else{this.computeFaceNormals();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];t[s.a].add(s.normal),t[s.b].add(s.normal),t[s.c].add(s.normal)}}for(let s=0,r=this.vertices.length;s<r;s++)t[s].normalize();for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s],r=e.vertexNormals;3===r.length?(r[0].copy(t[e.a]),r[1].copy(t[e.b]),r[2].copy(t[e.c])):(r[0]=t[e.a].clone(),r[1]=t[e.b].clone(),r[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,s=e.vertexNormals.length;t<s;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new E;e.faces=this.faces;for(let t=0,r=this.morphTargets.length;t<r;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,r=this.morphNormals[t].vertexNormals;for(let t=0,o=this.faces.length;t<o;t++){const t=new s,o={a:new s,b:new s,c:new s};e.push(t),r.push(o)}}const r=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=r.faceNormals[e],o=r.vertexNormals[e];s.copy(t.normal),o.a.copy(t.vertexNormals[0]),o.b.copy(t.vertexNormals[1]),o.c.copy(t.vertexNormals[2])}}for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new i),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new a),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,s=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const n=this.vertices.length,i=this.vertices,a=e.vertices,h=this.faces,l=e.faces,c=this.colors,u=e.colors;void 0!==t&&(r=(new o).getNormalMatrix(t));for(let o=0,m=a.length;o<m;o++){const e=a[o].clone();void 0!==t&&e.applyMatrix4(t),i.push(e)}for(let o=0,m=u.length;o<m;o++)c.push(u[o].clone());for(let o=0,m=l.length;o<m;o++){const e=l[o];let t,i;const a=e.vertexNormals,c=e.vertexColors,u=new I(e.a+n,e.b+n,e.c+n);u.normal.copy(e.normal),void 0!==r&&u.normal.applyMatrix3(r).normalize();for(let s=0,o=a.length;s<o;s++)t=a[s].clone(),void 0!==r&&t.applyMatrix3(r).normalize(),u.vertexNormals.push(t);u.color.copy(e.color);for(let s=0,r=c.length;s<r;s++)i=c[s],u.vertexColors.push(i.clone());u.materialIndex=e.materialIndex+s,h.push(u)}for(let o=0,m=e.faceVertexUvs.length;o<m;o++){const t=e.faceVertexUvs[o];void 0===this.faceVertexUvs[o]&&(this.faceVertexUvs[o]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++)r.push(s[e].clone());this.faceVertexUvs[o].push(r)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(e=4){const t={},s=[],r=[],o=Math.pow(10,e);for(let a=0,h=this.vertices.length;a<h;a++){const e=this.vertices[a],n=Math.round(e.x*o)+"_"+Math.round(e.y*o)+"_"+Math.round(e.z*o);void 0===t[n]?(t[n]=a,s.push(this.vertices[a]),r[a]=s.length-1):r[a]=r[t[n]]}const n=[];for(let a=0,h=this.faces.length;a<h;a++){const e=this.faces[a];e.a=r[e.a],e.b=r[e.b],e.c=r[e.c];const t=[e.a,e.b,e.c];for(let s=0;s<3;s++)if(t[s]===t[(s+1)%3]){n.push(a);break}}for(let a=n.length-1;a>=0;a--){const e=n[a];this.faces.splice(e,1);for(let t=0,s=this.faceVertexUvs.length;t<s;t++)this.faceVertexUvs[t].splice(e,1)}const i=this.vertices.length-s.length;return this.vertices=s,i},setFromPoints:function(e){this.vertices=[];for(let t=0,r=e.length;t<r;t++){const r=e[t];this.vertices.push(new s(r.x,r.y,r.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let i=0;i<t;i++)e[i]._id=i;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let o,n;s&&s.length===t&&(o=[]),r&&r.length===t&&(n=[]);for(let i=0;i<t;i++){const t=e[i]._id;o&&o.push(s[t]),n&&n.push(r[t])}o&&(this.faceVertexUvs[0]=o),n&&(this.faceVertexUvs[1]=n)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let p=0;p<this.vertices.length;p++){const e=this.vertices[p];t.push(e.x,e.y,e.z)}const s=[],r=[],o={},n=[],i={},a=[],h={};for(let p=0;p<this.faces.length;p++){const e=this.faces[p],t=!0,r=!1,o=void 0!==this.faceVertexUvs[0][p],n=e.normal.length()>0,i=e.vertexNormals.length>0,a=1!==e.color.r||1!==e.color.g||1!==e.color.b,h=e.vertexColors.length>0;let d=0;if(d=l(d,0,0),d=l(d,1,t),d=l(d,2,r),d=l(d,3,o),d=l(d,4,n),d=l(d,5,i),d=l(d,6,a),d=l(d,7,h),s.push(d),s.push(e.a,e.b,e.c),s.push(e.materialIndex),o){const e=this.faceVertexUvs[0][p];s.push(m(e[0]),m(e[1]),m(e[2]))}if(n&&s.push(c(e.normal)),i){const t=e.vertexNormals;s.push(c(t[0]),c(t[1]),c(t[2]))}if(a&&s.push(u(e.color)),h){const t=e.vertexColors;s.push(u(t[0]),u(t[1]),u(t[2]))}}function l(e,t,s){return s?e|1<<t:e&~(1<<t)}function c(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==o[t]||(o[t]=r.length/3,r.push(e.x,e.y,e.z)),o[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=n.length,n.push(e.getHex())),i[t]}function m(e){const t=e.x.toString()+e.y.toString();return void 0!==h[t]||(h[t]=a.length/2,a.push(e.x,e.y)),h[t]}return e.data={},e.data.vertices=t,e.data.normals=r,n.length>0&&(e.data.colors=n),a.length>0&&(e.data.uvs=[a]),e.data.faces=s,e},clone:function(){return(new E).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,m=t.length;u<m;u++)this.vertices.push(t[u].clone());const s=e.colors;for(let u=0,m=s.length;u<m;u++)this.colors.push(s[u].clone());const r=e.faces;for(let u=0,m=r.length;u<m;u++)this.faces.push(r[u].clone());for(let u=0,m=e.faceVertexUvs.length;u<m;u++){const t=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++){const t=s[e];r.push(t.clone())}this.faceVertexUvs[u].push(r)}}const o=e.morphTargets;for(let u=0,m=o.length;u<m;u++){const e={};if(e.name=o[u].name,void 0!==o[u].vertices){e.vertices=[];for(let t=0,s=o[u].vertices.length;t<s;t++)e.vertices.push(o[u].vertices[t].clone())}if(void 0!==o[u].normals){e.normals=[];for(let t=0,s=o[u].normals.length;t<s;t++)e.normals.push(o[u].normals[t].clone())}this.morphTargets.push(e)}const n=e.morphNormals;for(let u=0,m=n.length;u<m;u++){const e={};if(void 0!==n[u].vertexNormals){e.vertexNormals=[];for(let t=0,s=n[u].vertexNormals.length;t<s;t++){const s=n[u].vertexNormals[t],r={};r.a=s.a.clone(),r.b=s.b.clone(),r.c=s.c.clone(),e.vertexNormals.push(r)}}if(void 0!==n[u].faceNormals){e.faceNormals=[];for(let t=0,s=n[u].faceNormals.length;t<s;t++)e.faceNormals.push(n[u].faceNormals[t].clone())}this.morphNormals.push(e)}const i=e.skinWeights;for(let u=0,m=i.length;u<m;u++)this.skinWeights.push(i[u].clone());const a=e.skinIndices;for(let u=0,m=a.length;u<m;u++)this.skinIndices.push(a[u].clone());const h=e.lineDistances;for(let u=0,m=h.length;u<m;u++)this.lineDistances.push(h[u]);const l=e.boundingBox;null!==l&&(this.boundingBox=l.clone());const c=e.boundingSphere;return null!==c&&(this.boundingSphere=c.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},toBufferGeometry:function(){const e=(new G).fromGeometry(this),t=new h,s=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",new l(s,3).copyVector3sArray(e.vertices)),e.normals.length>0){const s=new Float32Array(3*e.normals.length);t.setAttribute("normal",new l(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const s=new Float32Array(3*e.colors.length);t.setAttribute("color",new l(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const s=new Float32Array(2*e.uvs.length);t.setAttribute("uv",new l(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const s=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",new l(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const r in e.morphTargets){const s=[],o=e.morphTargets[r];for(let e=0,t=o.length;e<t;e++){const t=o[e],r=new c(3*t.data.length,3);r.name=t.name,s.push(r.copyVector3sArray(t.data))}t.morphAttributes[r]=s}if(e.skinIndices.length>0){const s=new c(4*e.skinIndices.length,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const s=new c(4*e.skinWeights.length,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t},computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},dispose:function(){this.dispatchEvent({type:"dispose"})}}),E.createBufferGeometryFromObject=function(e){let t=new h;const s=e.geometry;if(e.isPoints||e.isLine){const e=new c(3*s.vertices.length,3),r=new c(3*s.colors.length,3);if(t.setAttribute("position",e.copyVector3sArray(s.vertices)),t.setAttribute("color",r.copyColorsArray(s.colors)),s.lineDistances&&s.lineDistances.length===s.vertices.length){const e=new c(s.lineDistances.length,1);t.setAttribute("lineDistance",e.copyArray(s.lineDistances))}null!==s.boundingSphere&&(t.boundingSphere=s.boundingSphere.clone()),null!==s.boundingBox&&(t.boundingBox=s.boundingBox.clone())}else e.isMesh&&(t=s.toBufferGeometry());return t};class G{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,r,o;const n=e.faces;for(r=0;r<n.length;r++){const e=n[r];e.materialIndex!==o&&(o=e.materialIndex,void 0!==s&&(s.count=3*r-s.start,t.push(s)),s={start:3*r,materialIndex:o})}void 0!==s&&(s.count=3*r-s.start,t.push(s)),this.groups=t}fromGeometry(e){const t=e.faces,s=e.vertices,r=e.faceVertexUvs,o=r[0]&&r[0].length>0,n=r[1]&&r[1].length>0,i=e.morphTargets,a=i.length;let h;if(a>0){h=[];for(let e=0;e<a;e++)h[e]={name:i[e].name,data:[]};this.morphTargets.position=h}const l=e.morphNormals,c=l.length;let m;if(c>0){m=[];for(let e=0;e<c;e++)m[e]={name:l[e].name,data:[]};this.morphTargets.normal=m}const p=e.skinIndices,d=e.skinWeights,g=p.length===s.length,f=d.length===s.length;s.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let v=0;v<t.length;v++){const e=t[v];this.vertices.push(s[e.a],s[e.b],s[e.c]);const x=e.vertexNormals;if(3===x.length)this.normals.push(x[0],x[1],x[2]);else{const t=e.normal;this.normals.push(t,t,t)}const y=e.vertexColors;if(3===y.length)this.colors.push(y[0],y[1],y[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===o){const e=r[0][v];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",v),this.uvs.push(new u,new u,new u))}if(!0===n){const e=r[1][v];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",v),this.uvs2.push(new u,new u,new u))}for(let t=0;t<a;t++){const s=i[t].vertices;h[t].data.push(s[e.a],s[e.b],s[e.c])}for(let t=0;t<c;t++){const e=l[t].vertexNormals[v];m[t].data.push(e.a,e.b,e.c)}g&&this.skinIndices.push(p[e.a],p[e.b],p[e.c]),f&&this.skinWeights.push(d[e.a],d[e.b],d[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class I{constructor(e,t,r,o,i,a=0){this.a=e,this.b=t,this.c=r,this.normal=o&&o.isVector3?o:new s,this.vertexNormals=Array.isArray(o)?o:[],this.color=i&&i.isColor?i:new n,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=a}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}class _{constructor(e){Object.entries(e).forEach((([e,t])=>{this[e]=t})),this.o3d=new t,this.uProgress={value:0},this.uvScale=new u,this.initMaterial(),this.initPlane()}initMaterial(){this.material=new p({side:d,transparent:!0,map:this.texture,onBeforeCompile:e=>{e.uniforms.progress=this.uProgress,e.uniforms.uvScale={value:this.uvScale},e.vertexShader="\n          uniform float progress;\n          uniform vec2 uvScale;\n\n          attribute vec3 offset;\n          attribute vec3 rotation;\n          attribute vec2 uvOffset;\n\n          mat3 rotationMatrixXYZ(vec3 r)\n          {\n            float cx = cos(r.x);\n            float sx = sin(r.x);\n            float cy = cos(r.y);\n            float sy = sin(r.y);\n            float cz = cos(r.z);\n            float sz = sin(r.z);\n\n            return mat3(\n               cy * cz, cx * sz + sx * sy * cz, sx * sz - cx * sy * cz,\n              -cy * sz, cx * cz - sx * sy * sz, sx * cz + cx * sy * sz,\n                    sy,               -sx * cy,                cx * cy\n            );\n          }\n        "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <uv_vertex>","\n          #include <uv_vertex>\n          vUv = vUv * uvScale + uvOffset;\n        "),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n          mat3 rotMat = rotationMatrixXYZ(progress * rotation);\n          transformed = rotMat * transformed;\n\n          vec4 mvPosition = vec4(transformed, 1.0);\n          #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n          #endif\n\n          mvPosition.xyz += progress * offset;\n\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n        ")}})}initPlane(){const{width:e,wWidth:s,wHeight:r}=this.screen;this.wSize=this.size*s/e,this.nx=Math.ceil(s/this.wSize)+1,this.ny=Math.ceil(r/this.wSize)+1,this.icount=this.nx*this.ny,this.initGeometry(),this.initUV(),this.initAnimAttributes(),this.imesh&&this.o3d.remove(this.imesh),this.imesh=new g(this.bGeometry,this.material,this.icount),this.o3d.add(this.imesh);const o=new t;let n=0,i=-(s-(s-this.nx*this.wSize))/2+this.dx;for(let t=0;t<this.nx;t++){let e=-(r-(r-this.ny*this.wSize))/2+this.dy;for(let t=0;t<this.ny;t++)o.position.set(i,e,0),o.updateMatrix(),this.imesh.setMatrixAt(n++,o.matrix),e+=this.wSize;i+=this.wSize}}initGeometry(){const e=new E;e.vertices.push(new s(0,0,0)),e.vertices.push(new s(this.wSize,0,0)),e.vertices.push(new s(0,this.wSize,0)),e.vertices.push(new s(this.wSize,this.wSize,0)),e.faces.push(new f(0,2,1)),e.faces.push(new f(2,3,1)),e.faceVertexUvs[0].push([new u(0,0),new u(0,1),new u(1,0)]),e.faceVertexUvs[0].push([new u(0,1),new u(1,1),new u(1,0)]),this.dx=this.wSize/2,this.dy=this.wSize/2,e.translate(-this.dx,-this.dy,0),this.bGeometry=e.toBufferGeometry()}initAnimAttributes(){const{randFloat:e,randFloatSpread:t}=m,r=new s,o=new Float32Array(3*this.icount);for(let s=0;s<o.length;s+=3)1===this.anim?r.set(t(10),e(50,100),e(20,50)).toArray(o,s):r.set(t(20),t(20),e(20,200)).toArray(o,s);this.bGeometry.setAttribute("offset",new v(o,3));const n=new Float32Array(3*this.icount),i=4*Math.PI;for(let s=0;s<n.length;s+=3)n[s]=t(i),n[s+1]=t(i),n[s+2]=t(i);this.bGeometry.setAttribute("rotation",new v(n,3))}initUV(){const e=this.nx/this.ny,t=this.texture.image.width/this.texture.image.height;e>t?this.uvScale.set(1/this.nx,t/e/this.ny):this.uvScale.set(e/t/this.nx,1/this.ny);const s=this.uvScale.x*this.nx,r=this.uvScale.y*this.ny,o=new u,n=new Float32Array(2*this.icount);for(let i=0;i<this.nx;i++)for(let e=0;e<this.ny;e++)o.set(this.uvScale.x*i+(1-s)/2,this.uvScale.y*e+(1-r)/2).toArray(n,2*(i*this.ny+e));this.bGeometry.setAttribute("uvOffset",new v(n,2))}setTexture(e){this.texture=e,this.material.map=e,this.initUV()}resize(){this.initPlane()}}const C={components:{Camera:N,Renderer:w,Scene:U},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup:()=>({loader:x(),progress:0,targetProgress:0}),mounted(){this.three=this.$refs.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.three.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),y.fromTo(this.plane1.uProgress,{value:-2},{value:0,duration:2.5,ease:b.easeOut});const e=this.three.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.three.onBeforeRender(this.updateProgress),this.three.onAfterResize(this.onResize)},initScene(){const e=this.three.renderer,s=this.$refs.scene.scene;this.plane1=new _({renderer:e,screen:this.three.size,size:10,anim:1,texture:this.loader.textures[0]}),this.plane2=new _({renderer:e,screen:this.three.size,size:10,anim:2,texture:this.loader.textures[1]}),this.setPlanesProgress(0),this.planes=new t,this.planes.add(this.plane1.o3d),this.planes.add(this.plane2.o3d),s.add(this.planes)},onResize(){this.plane1.resize(),this.plane2.resize()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.three.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=S(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,r=e%1;if(t>0&&r<s||t<0&&s<r){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.plane1.setTexture(this.loader.textures[t]),this.plane2.setTexture(this.loader.textures[s])}this.progress=e,this.setPlanesProgress(this.progress%1)},setPlanesProgress(e){this.plane1.uProgress.value=e,this.plane2.uProgress.value=-1+e,this.plane1.material.opacity=1-e,this.plane2.material.opacity=e,this.plane1.o3d.position.z=e,this.plane2.o3d.position.z=e-1}}};C.render=function(e,t,s,r,o,n){const i=A("Camera"),a=A("Scene"),h=A("Renderer");return z(),P(h,{ref:"renderer",antialias:"",resize:""},{default:V((()=>[B(i,{ref:"camera",position:{z:150}},null,512),B(a,{ref:"scene"},null,512)])),_:1},512)};const F={components:{Slider:C},data:()=>({images:[{src:"/assets/images/img1.jpg"},{src:"/assets/images/img2.jpg"},{src:"/assets/images/img3.jpg"},{src:"/assets/images/img4.jpg"}]})};F.render=function(e,t,s,r,o,n){const i=A("Slider");return z(),P(i,{images:o.images},null,8,["images"])};export default F;
