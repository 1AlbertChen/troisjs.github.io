import{i as e,b as t,V as s,P as r,S as a,M as i}from"./OrbitControls.ee6c153c.js";import{u as n,g as o,P as h}from"./useTextures.85b29595.js";import{n as g,r as l,o as m,c as u,w as c,a as p}from"./app.39908f78.js";import{u as d,a as v,l as f}from"./useBindProp.11ff877e.js";import{R as P,S as y}from"./Scene.311c5b22.js";function x(e){let t,n,o;const h={value:null},g={value:new s(.5,.5)},l={value:0},m={value:new s(0,0)},u={value:new s(1,1)};return t=new r(2,2,1,1),n=new a({transparent:!0,uniforms:{map:h,center:g,strength:l,uvOffset:m,uvScale:u},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform sampler2D map;\n        uniform vec2 center;\n        uniform float strength;\n        uniform vec2 uvOffset;\n        uniform vec2 uvScale;\n        varying vec2 vUv;\n\n        float random(vec3 scale, float seed) {\n          /* use the fragment position for a different seed per-pixel */\n          return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n        \n        void main() {\n          vec2 tUv = vUv * uvScale + uvOffset;\n          if (abs(strength) > 0.001) {\n            vec4 color = vec4(0.0);\n            float total = 0.0;\n            vec2 toCenter = center * uvScale + uvOffset - tUv;\n            \n            /* randomize the lookup values to hide the fixed number of samples */\n            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n            \n            for (float t = 0.0; t <= 20.0; t++) {\n              float percent = (t + offset) / 20.0;\n              float weight = 2.0 * (percent - percent * percent);\n              vec4 texel = texture2D(map, tUv + toCenter * percent * strength);\n\n              /* switch to pre-multiplied alpha to correctly blur transparent images */\n              texel.rgb *= texel.a;\n\n              color += texel * weight;\n              total += weight;\n            }\n\n            gl_FragColor = color / total;\n\n            /* switch back from pre-multiplied alpha */\n            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n            gl_FragColor.a = 1.0 - abs(strength);\n          } else {\n            gl_FragColor = texture2D(map, tUv);\n          }\n        }\n      "}),o=new i(t,n),{geometry:t,material:n,mesh:o,uCenter:g,uStrength:l,setMap:function(e){h.value=e,c()},updateUV:c};function c(){const t=e.size.ratio,s=h.value.image.width/h.value.image.height;m.value.set(0,0),u.value.set(1,1),s>t?(u.value.x=t/s,m.value.x=(1-u.value.x)/2):(u.value.y=s/t,m.value.y=(1-u.value.y)/2)}}const b={components:{OrthographicCamera:{inject:["three"],props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:[Object,e],default:{x:0,y:0,z:0}}},created(){this.camera=new t(this.left,this.right,this.top,this.bottom,this.near,this.far),d(this,"position",this.camera.position),["left","right","top","bottom","near","far","zoom"].forEach((e=>{g((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},render:()=>[],__hmrId:"OrthographicCamera"},Renderer:P,Scene:y},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup(){const e=new s;return{loader:n(),center:e,progress:0,targetProgress:0}},mounted(){this.three=this.$refs.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.three.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),o.fromTo(this.image1.uStrength,{value:-2},{value:0,duration:2.5,ease:h.easeOut});const e=this.three.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.three.onBeforeRender(this.animate),this.three.onAfterResize(this.onResize)},initScene(){const e=this.$refs.scene.scene;this.image1=new x(this.three),this.image1.setMap(this.loader.textures[0]),this.image2=new x(this.three),this.image2.setMap(this.loader.textures[1]),this.setImagesProgress(0),e.add(this.image1.mesh),e.add(this.image2.mesh)},animate(){const{mouse:e}=this.three;this.center.copy(e).divideScalar(2).addScalar(.5),v(this.image1.uCenter.value,this.center,.1),v(this.image2.uCenter.value,this.center,.1),this.updateProgress()},onResize(){this.image1.updateUV(),this.image2.updateUV()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.three.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=f(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,r=e%1;if(t>0&&r<s||t<0&&s<r){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.image1.setMap(this.loader.textures[t]),this.image2.setMap(this.loader.textures[s])}this.progress=e,this.setImagesProgress(this.progress%1)},setImagesProgress(e){this.image1.uStrength.value=e,this.image2.uStrength.value=-1+e}}};b.render=function(e,t,s,r,a,i){const n=l("OrthographicCamera"),o=l("Scene"),h=l("Renderer");return m(),u(h,{ref:"renderer",antialias:"","mouse-move":""},{default:c((()=>[p(n,{ref:"camera",position:{z:10}},null,512),p(o,{ref:"scene"},null,512)])),_:1},512)};const w={components:{Slider:b},data:()=>({images:[{src:"/assets/images/img10.jpg"},{src:"/assets/images/img6.jpg"},{src:"/assets/images/img7.jpg"},{src:"/assets/images/img8.jpg"},{src:"/assets/images/img2.jpg"}]})};w.render=function(e,t,s,r,a,i){const n=l("Slider");return m(),u(n,{images:a.images},null,8,["images"])};export default w;
