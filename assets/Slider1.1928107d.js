import{A as e,X as t,O as s,E as r,b6 as o,aq as i,af as n,k as a,ag as h,ah as l,B as c,p as u,c as m,V as p,f as d,u as g,aW as f,I as v}from"./OrbitControls.68836727.js";import{R as x,S as y,u as b,g as N,P as w}from"./useTextures.e0a8d941.js";import{n as U,r as S,o as A,c as z,w as P,b as k}from"./app.d50cbeef.js";import{b as V,l as B}from"./tools.e90cd5b1.js";var M={name:"PerspectiveCamera",inject:["three"],props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:{x:0,y:0,z:0}},lookAt:{type:Object,default:null}},created(){this.camera=new e(this.fov,this.aspect,this.near,this.far),V(this,"position",this.camera),this.lookAt&&this.camera.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),U((()=>this.lookAt),(e=>{this.camera.lookAt(e.x,e.y,e.z)}),{deep:!0}),["aspect","far","fov","near"].forEach((e=>{U((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},render:()=>[],__hmrId:"PerspectiveCamera"};const T=new t,E=new s,G=new n;function I(){this.uuid=r.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}I.prototype=Object.assign(Object.create(o.prototype),{constructor:I,isGeometry:!0,applyMatrix4:function(e){const t=(new i).getNormalMatrix(e);for(let s=0,r=this.vertices.length;s<r;s++){this.vertices[s].applyMatrix4(e)}for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s];e.normal.applyMatrix3(t).normalize();for(let s=0,r=e.vertexNormals.length;s<r;s++)e.vertexNormals[s].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return T.makeRotationX(e),this.applyMatrix4(T),this},rotateY:function(e){return T.makeRotationY(e),this.applyMatrix4(T),this},rotateZ:function(e){return T.makeRotationZ(e),this.applyMatrix4(T),this},translate:function(e,t,s){return T.makeTranslation(e,t,s),this.applyMatrix4(T),this},scale:function(e,t,s){return T.makeScale(e,t,s),this.applyMatrix4(T),this},lookAt:function(e){return E.lookAt(e),E.updateMatrix(),this.applyMatrix4(E.matrix),this},fromBufferGeometry:function(e){const t=this,s=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const o=r.position,i=r.normal,h=r.color,l=r.uv,c=r.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let p=0;p<o.count;p++)t.vertices.push((new n).fromBufferAttribute(o,p)),void 0!==h&&t.colors.push((new a).fromBufferAttribute(h,p));function u(e,s,r,o){const a=void 0===h?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[r].clone()],u=void 0===i?[]:[(new n).fromBufferAttribute(i,e),(new n).fromBufferAttribute(i,s),(new n).fromBufferAttribute(i,r)],m=new C(e,s,r,u,a,o);t.faces.push(m),void 0!==l&&t.faceVertexUvs[0].push([(new p).fromBufferAttribute(l,e),(new p).fromBufferAttribute(l,s),(new p).fromBufferAttribute(l,r)]),void 0!==c&&t.faceVertexUvs[1].push([(new p).fromBufferAttribute(c,e),(new p).fromBufferAttribute(c,s),(new p).fromBufferAttribute(c,r)])}const m=e.groups;if(m.length>0)for(let n=0;n<m.length;n++){const e=m[n],t=e.start;for(let r=t,o=t+e.count;r<o;r+=3)void 0!==s?u(s.getX(r),s.getX(r+1),s.getX(r+2),e.materialIndex):u(r,r+1,r+2,e.materialIndex)}else if(void 0!==s)for(let n=0;n<s.count;n+=3)u(s.getX(n),s.getX(n+1),s.getX(n+2));else for(let n=0;n<o.count;n+=3)u(n,n+1,n+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(G).negate(),this.translate(G.x,G.y,G.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,s=this.boundingSphere.radius,r=0===s?1:1/s,o=new t;return o.set(r,0,0,-r*e.x,0,r,0,-r*e.y,0,0,r,-r*e.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){const e=new n,t=new n;for(let s=0,r=this.faces.length;s<r;s++){const r=this.faces[s],o=this.vertices[r.a],i=this.vertices[r.b],n=this.vertices[r.c];e.subVectors(n,i),t.subVectors(o,i),e.cross(t),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let s=0,r=this.vertices.length;s<r;s++)t[s]=new n;if(e){const e=new n,s=new n;for(let r=0,o=this.faces.length;r<o;r++){const o=this.faces[r],i=this.vertices[o.a],n=this.vertices[o.b],a=this.vertices[o.c];e.subVectors(a,n),s.subVectors(i,n),e.cross(s),t[o.a].add(e),t[o.b].add(e),t[o.c].add(e)}}else{this.computeFaceNormals();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];t[s.a].add(s.normal),t[s.b].add(s.normal),t[s.c].add(s.normal)}}for(let s=0,r=this.vertices.length;s<r;s++)t[s].normalize();for(let s=0,r=this.faces.length;s<r;s++){const e=this.faces[s],r=e.vertexNormals;3===r.length?(r[0].copy(t[e.a]),r[1].copy(t[e.b]),r[2].copy(t[e.c])):(r[0]=t[e.a].clone(),r[1]=t[e.b].clone(),r[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,s=e.vertexNormals.length;t<s;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new I;e.faces=this.faces;for(let t=0,s=this.morphTargets.length;t<s;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(let t=0,r=this.faces.length;t<r;t++){const t=new n,r={a:new n,b:new n,c:new n};e.push(t),s.push(r)}}const s=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],r=s.faceNormals[e],o=s.vertexNormals[e];r.copy(t.normal),o.a.copy(t.vertexNormals[0]),o.b.copy(t.vertexNormals[1]),o.c.copy(t.vertexNormals[2])}}for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new h),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new l),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,s=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const o=this.vertices.length,n=this.vertices,a=e.vertices,h=this.faces,l=e.faces,c=this.colors,u=e.colors;void 0!==t&&(r=(new i).getNormalMatrix(t));for(let i=0,m=a.length;i<m;i++){const e=a[i].clone();void 0!==t&&e.applyMatrix4(t),n.push(e)}for(let i=0,m=u.length;i<m;i++)c.push(u[i].clone());for(let i=0,m=l.length;i<m;i++){const e=l[i];let t,n;const a=e.vertexNormals,c=e.vertexColors,u=new C(e.a+o,e.b+o,e.c+o);u.normal.copy(e.normal),void 0!==r&&u.normal.applyMatrix3(r).normalize();for(let s=0,o=a.length;s<o;s++)t=a[s].clone(),void 0!==r&&t.applyMatrix3(r).normalize(),u.vertexNormals.push(t);u.color.copy(e.color);for(let s=0,r=c.length;s<r;s++)n=c[s],u.vertexColors.push(n.clone());u.materialIndex=e.materialIndex+s,h.push(u)}for(let i=0,m=e.faceVertexUvs.length;i<m;i++){const t=e.faceVertexUvs[i];void 0===this.faceVertexUvs[i]&&(this.faceVertexUvs[i]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++)r.push(s[e].clone());this.faceVertexUvs[i].push(r)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(e=4){const t={},s=[],r=[],o=Math.pow(10,e);for(let a=0,h=this.vertices.length;a<h;a++){const e=this.vertices[a],i=Math.round(e.x*o)+"_"+Math.round(e.y*o)+"_"+Math.round(e.z*o);void 0===t[i]?(t[i]=a,s.push(this.vertices[a]),r[a]=s.length-1):r[a]=r[t[i]]}const i=[];for(let a=0,h=this.faces.length;a<h;a++){const e=this.faces[a];e.a=r[e.a],e.b=r[e.b],e.c=r[e.c];const t=[e.a,e.b,e.c];for(let s=0;s<3;s++)if(t[s]===t[(s+1)%3]){i.push(a);break}}for(let a=i.length-1;a>=0;a--){const e=i[a];this.faces.splice(e,1);for(let t=0,s=this.faceVertexUvs.length;t<s;t++)this.faceVertexUvs[t].splice(e,1)}const n=this.vertices.length-s.length;return this.vertices=s,n},setFromPoints:function(e){this.vertices=[];for(let t=0,s=e.length;t<s;t++){const s=e[t];this.vertices.push(new n(s.x,s.y,s.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let n=0;n<t;n++)e[n]._id=n;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let o,i;s&&s.length===t&&(o=[]),r&&r.length===t&&(i=[]);for(let n=0;n<t;n++){const t=e[n]._id;o&&o.push(s[t]),i&&i.push(r[t])}o&&(this.faceVertexUvs[0]=o),i&&(this.faceVertexUvs[1]=i)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let p=0;p<this.vertices.length;p++){const e=this.vertices[p];t.push(e.x,e.y,e.z)}const s=[],r=[],o={},i=[],n={},a=[],h={};for(let p=0;p<this.faces.length;p++){const e=this.faces[p],t=!0,r=!1,o=void 0!==this.faceVertexUvs[0][p],i=e.normal.length()>0,n=e.vertexNormals.length>0,a=1!==e.color.r||1!==e.color.g||1!==e.color.b,h=e.vertexColors.length>0;let d=0;if(d=l(d,0,0),d=l(d,1,t),d=l(d,2,r),d=l(d,3,o),d=l(d,4,i),d=l(d,5,n),d=l(d,6,a),d=l(d,7,h),s.push(d),s.push(e.a,e.b,e.c),s.push(e.materialIndex),o){const e=this.faceVertexUvs[0][p];s.push(m(e[0]),m(e[1]),m(e[2]))}if(i&&s.push(c(e.normal)),n){const t=e.vertexNormals;s.push(c(t[0]),c(t[1]),c(t[2]))}if(a&&s.push(u(e.color)),h){const t=e.vertexColors;s.push(u(t[0]),u(t[1]),u(t[2]))}}function l(e,t,s){return s?e|1<<t:e&~(1<<t)}function c(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==o[t]||(o[t]=r.length/3,r.push(e.x,e.y,e.z)),o[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==n[t]||(n[t]=i.length,i.push(e.getHex())),n[t]}function m(e){const t=e.x.toString()+e.y.toString();return void 0!==h[t]||(h[t]=a.length/2,a.push(e.x,e.y)),h[t]}return e.data={},e.data.vertices=t,e.data.normals=r,i.length>0&&(e.data.colors=i),a.length>0&&(e.data.uvs=[a]),e.data.faces=s,e},clone:function(){return(new I).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,m=t.length;u<m;u++)this.vertices.push(t[u].clone());const s=e.colors;for(let u=0,m=s.length;u<m;u++)this.colors.push(s[u].clone());const r=e.faces;for(let u=0,m=r.length;u<m;u++)this.faces.push(r[u].clone());for(let u=0,m=e.faceVertexUvs.length;u<m;u++){const t=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],r=[];for(let e=0,t=s.length;e<t;e++){const t=s[e];r.push(t.clone())}this.faceVertexUvs[u].push(r)}}const o=e.morphTargets;for(let u=0,m=o.length;u<m;u++){const e={};if(e.name=o[u].name,void 0!==o[u].vertices){e.vertices=[];for(let t=0,s=o[u].vertices.length;t<s;t++)e.vertices.push(o[u].vertices[t].clone())}if(void 0!==o[u].normals){e.normals=[];for(let t=0,s=o[u].normals.length;t<s;t++)e.normals.push(o[u].normals[t].clone())}this.morphTargets.push(e)}const i=e.morphNormals;for(let u=0,m=i.length;u<m;u++){const e={};if(void 0!==i[u].vertexNormals){e.vertexNormals=[];for(let t=0,s=i[u].vertexNormals.length;t<s;t++){const s=i[u].vertexNormals[t],r={};r.a=s.a.clone(),r.b=s.b.clone(),r.c=s.c.clone(),e.vertexNormals.push(r)}}if(void 0!==i[u].faceNormals){e.faceNormals=[];for(let t=0,s=i[u].faceNormals.length;t<s;t++)e.faceNormals.push(i[u].faceNormals[t].clone())}this.morphNormals.push(e)}const n=e.skinWeights;for(let u=0,m=n.length;u<m;u++)this.skinWeights.push(n[u].clone());const a=e.skinIndices;for(let u=0,m=a.length;u<m;u++)this.skinIndices.push(a[u].clone());const h=e.lineDistances;for(let u=0,m=h.length;u<m;u++)this.lineDistances.push(h[u]);const l=e.boundingBox;null!==l&&(this.boundingBox=l.clone());const c=e.boundingSphere;return null!==c&&(this.boundingSphere=c.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},toBufferGeometry:function(){const e=(new _).fromGeometry(this),t=new c,s=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",new u(s,3).copyVector3sArray(e.vertices)),e.normals.length>0){const s=new Float32Array(3*e.normals.length);t.setAttribute("normal",new u(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const s=new Float32Array(3*e.colors.length);t.setAttribute("color",new u(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const s=new Float32Array(2*e.uvs.length);t.setAttribute("uv",new u(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const s=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",new u(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const r in e.morphTargets){const s=[],o=e.morphTargets[r];for(let e=0,t=o.length;e<t;e++){const t=o[e],r=new m(3*t.data.length,3);r.name=t.name,s.push(r.copyVector3sArray(t.data))}t.morphAttributes[r]=s}if(e.skinIndices.length>0){const s=new m(4*e.skinIndices.length,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const s=new m(4*e.skinWeights.length,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t},computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},dispose:function(){this.dispatchEvent({type:"dispose"})}}),I.createBufferGeometryFromObject=function(e){let t=new c;const s=e.geometry;if(e.isPoints||e.isLine){const e=new m(3*s.vertices.length,3),r=new m(3*s.colors.length,3);if(t.setAttribute("position",e.copyVector3sArray(s.vertices)),t.setAttribute("color",r.copyColorsArray(s.colors)),s.lineDistances&&s.lineDistances.length===s.vertices.length){const e=new m(s.lineDistances.length,1);t.setAttribute("lineDistance",e.copyArray(s.lineDistances))}null!==s.boundingSphere&&(t.boundingSphere=s.boundingSphere.clone()),null!==s.boundingBox&&(t.boundingBox=s.boundingBox.clone())}else e.isMesh&&(t=s.toBufferGeometry());return t};class _{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,r,o;const i=e.faces;for(r=0;r<i.length;r++){const e=i[r];e.materialIndex!==o&&(o=e.materialIndex,void 0!==s&&(s.count=3*r-s.start,t.push(s)),s={start:3*r,materialIndex:o})}void 0!==s&&(s.count=3*r-s.start,t.push(s)),this.groups=t}fromGeometry(e){const t=e.faces,s=e.vertices,r=e.faceVertexUvs,o=r[0]&&r[0].length>0,i=r[1]&&r[1].length>0,n=e.morphTargets,a=n.length;let h;if(a>0){h=[];for(let e=0;e<a;e++)h[e]={name:n[e].name,data:[]};this.morphTargets.position=h}const l=e.morphNormals,c=l.length;let u;if(c>0){u=[];for(let e=0;e<c;e++)u[e]={name:l[e].name,data:[]};this.morphTargets.normal=u}const m=e.skinIndices,d=e.skinWeights,g=m.length===s.length,f=d.length===s.length;s.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let v=0;v<t.length;v++){const e=t[v];this.vertices.push(s[e.a],s[e.b],s[e.c]);const x=e.vertexNormals;if(3===x.length)this.normals.push(x[0],x[1],x[2]);else{const t=e.normal;this.normals.push(t,t,t)}const y=e.vertexColors;if(3===y.length)this.colors.push(y[0],y[1],y[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===o){const e=r[0][v];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",v),this.uvs.push(new p,new p,new p))}if(!0===i){const e=r[1][v];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",v),this.uvs2.push(new p,new p,new p))}for(let t=0;t<a;t++){const s=n[t].vertices;h[t].data.push(s[e.a],s[e.b],s[e.c])}for(let t=0;t<c;t++){const e=l[t].vertexNormals[v];u[t].data.push(e.a,e.b,e.c)}g&&this.skinIndices.push(m[e.a],m[e.b],m[e.c]),f&&this.skinWeights.push(d[e.a],d[e.b],d[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class C{constructor(e,t,s,r,o,i=0){this.a=e,this.b=t,this.c=s,this.normal=r&&r.isVector3?r:new n,this.vertexNormals=Array.isArray(r)?r:[],this.color=o&&o.isColor?o:new a,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=i}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}class F{constructor(e){Object.entries(e).forEach((([e,t])=>{this[e]=t})),this.o3d=new s,this.uProgress={value:0},this.uvScale=new p,this.initMaterial(),this.initPlane()}initMaterial(){this.material=new d({side:g,transparent:!0,map:this.texture,onBeforeCompile:e=>{e.uniforms.progress=this.uProgress,e.uniforms.uvScale={value:this.uvScale},e.vertexShader="\n          uniform float progress;\n          uniform vec2 uvScale;\n\n          attribute vec3 offset;\n          attribute vec3 rotation;\n          attribute vec2 uvOffset;\n\n          mat3 rotationMatrixXYZ(vec3 r)\n          {\n            float cx = cos(r.x);\n            float sx = sin(r.x);\n            float cy = cos(r.y);\n            float sy = sin(r.y);\n            float cz = cos(r.z);\n            float sz = sin(r.z);\n\n            return mat3(\n               cy * cz, cx * sz + sx * sy * cz, sx * sz - cx * sy * cz,\n              -cy * sz, cx * cz - sx * sy * sz, sx * cz + cx * sy * sz,\n                    sy,               -sx * cy,                cx * cy\n            );\n          }\n        "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <uv_vertex>","\n          #include <uv_vertex>\n          vUv = vUv * uvScale + uvOffset;\n        "),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n          mat3 rotMat = rotationMatrixXYZ(progress * rotation);\n          transformed = rotMat * transformed;\n\n          vec4 mvPosition = vec4(transformed, 1.0);\n          #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n          #endif\n\n          mvPosition.xyz += progress * offset;\n\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n        ")}})}initPlane(){const{width:e,wWidth:t,wHeight:r}=this.screen;this.wSize=this.size*t/e,this.nx=Math.ceil(t/this.wSize)+1,this.ny=Math.ceil(r/this.wSize)+1,this.icount=this.nx*this.ny,this.initGeometry(),this.initUV(),this.initAnimAttributes(),this.imesh&&this.o3d.remove(this.imesh),this.imesh=new f(this.bGeometry,this.material,this.icount),this.o3d.add(this.imesh);const o=new s;let i=0,n=-(t-(t-this.nx*this.wSize))/2+this.dx;for(let s=0;s<this.nx;s++){let e=-(r-(r-this.ny*this.wSize))/2+this.dy;for(let t=0;t<this.ny;t++)o.position.set(n,e,0),o.updateMatrix(),this.imesh.setMatrixAt(i++,o.matrix),e+=this.wSize;n+=this.wSize}}initGeometry(){const e=new I;e.vertices.push(new n(0,0,0)),e.vertices.push(new n(this.wSize,0,0)),e.vertices.push(new n(0,this.wSize,0)),e.vertices.push(new n(this.wSize,this.wSize,0)),e.faces.push(new C(0,2,1)),e.faces.push(new C(2,3,1)),e.faceVertexUvs[0].push([new p(0,0),new p(0,1),new p(1,0)]),e.faceVertexUvs[0].push([new p(0,1),new p(1,1),new p(1,0)]),this.dx=this.wSize/2,this.dy=this.wSize/2,e.translate(-this.dx,-this.dy,0),this.bGeometry=e.toBufferGeometry()}initAnimAttributes(){const{randFloat:e,randFloatSpread:t}=r,s=new n,o=new Float32Array(3*this.icount);for(let r=0;r<o.length;r+=3)1===this.anim?s.set(t(10),e(50,100),e(20,50)).toArray(o,r):s.set(t(20),t(20),e(20,200)).toArray(o,r);this.bGeometry.setAttribute("offset",new v(o,3));const i=new Float32Array(3*this.icount),a=4*Math.PI;for(let r=0;r<i.length;r+=3)i[r]=t(a),i[r+1]=t(a),i[r+2]=t(a);this.bGeometry.setAttribute("rotation",new v(i,3))}initUV(){const e=this.nx/this.ny,t=this.texture.image.width/this.texture.image.height;e>t?this.uvScale.set(1/this.nx,t/e/this.ny):this.uvScale.set(e/t/this.nx,1/this.ny);const s=this.uvScale.x*this.nx,r=this.uvScale.y*this.ny,o=new p,i=new Float32Array(2*this.icount);for(let n=0;n<this.nx;n++)for(let e=0;e<this.ny;e++)o.set(this.uvScale.x*n+(1-s)/2,this.uvScale.y*e+(1-r)/2).toArray(i,2*(n*this.ny+e));this.bGeometry.setAttribute("uvOffset",new v(i,2))}setTexture(e){this.texture=e,this.material.map=e,this.initUV()}resize(){this.initPlane()}}const R={components:{Camera:M,Renderer:x,Scene:y},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup:()=>({loader:b(),progress:0,targetProgress:0}),mounted(){this.three=this.$refs.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.three.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),N.fromTo(this.plane1.uProgress,{value:-2},{value:0,duration:2.5,ease:w.easeOut});const e=this.three.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.three.onBeforeRender(this.updateProgress),this.three.onAfterResize(this.onResize)},initScene(){const e=this.three.renderer,t=this.$refs.scene.scene;this.plane1=new F({renderer:e,screen:this.three.size,size:10,anim:1,texture:this.loader.textures[0]}),this.plane2=new F({renderer:e,screen:this.three.size,size:10,anim:2,texture:this.loader.textures[1]}),this.setPlanesProgress(0),this.planes=new s,this.planes.add(this.plane1.o3d),this.planes.add(this.plane2.o3d),t.add(this.planes)},onResize(){this.plane1.resize(),this.plane2.resize()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.three.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=B(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,r=e%1;if(t>0&&r<s||t<0&&s<r){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.plane1.setTexture(this.loader.textures[t]),this.plane2.setTexture(this.loader.textures[s])}this.progress=e,this.setPlanesProgress(this.progress%1)},setPlanesProgress(e){this.plane1.uProgress.value=e,this.plane2.uProgress.value=-1+e,this.plane1.material.opacity=1-e,this.plane2.material.opacity=e,this.plane1.o3d.position.z=e,this.plane2.o3d.position.z=e-1}}};R.render=function(e,t,s,r,o,i){const n=S("Camera"),a=S("Scene"),h=S("Renderer");return A(),z(h,{ref:"renderer",antialias:"",resize:""},{default:P((()=>[k(n,{ref:"camera",position:{z:150}},null,512),k(a,{ref:"scene"},null,512)])),_:1},512)};const j={components:{Slider:R},data:()=>({images:[{src:"/assets/images/img1.jpg"},{src:"/assets/images/img2.jpg"},{src:"/assets/images/img3.jpg"},{src:"/assets/images/img4.jpg"}]})};j.render=function(e,t,s,r,o,i){const n=S("Slider");return A(),z(n,{images:o.images},null,8,["images"])};export default j;
